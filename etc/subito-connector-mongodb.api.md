## API Report File for "subito-connector-mongodb"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Collection } from 'mongodb';
import { Document as Document_2 } from 'mongodb';
import { Fields } from 'apollo-datasource-mongodb';
import mongo from 'mongodb';
import { MongoDataSource } from 'apollo-datasource-mongodb';
import type { ObjectId } from 'mongodb';
import { Options } from 'apollo-datasource-mongodb';
import type { ParseType } from 'subito-lib';

export { Collection }

// @public
export class Connector {
    constructor(link: MongoDBLink, dbName: MongoDBName, params?: MongoDBParams, options?: MongoDBOptions);
    connect(): Promise<any>;
    // (undocumented)
    protected db: any;
    // (undocumented)
    protected dbName: MongoDBName;
    get(): any;
    // (undocumented)
    protected link: MongoDBLink;
    // (undocumented)
    protected options: MongoDBOptions;
    // (undocumented)
    protected params: string;
}

// @public (undocumented)
export type CursorEdge = {
    cursor: string;
    node: Document_2;
};

export { Document_2 as Document }

// @public (undocumented)
export type DocumentResult = Document_2 | null | undefined;

// @public (undocumented)
export type GenericCursors = 'ID' | 'CREATION_DATE' | 'DELETION_DATE' | 'SLUG';

// @public
export class Helper {
    static getFilterPipeline(filters: IFilterPipelineInput): IFiltersPipeline | null;
    static newMongoId(toString: boolean): string | mongo.ObjectId;
}

// @public (undocumented)
export interface ICursor {
    // (undocumented)
    field: string;
    // (undocumented)
    type: ParseType | 'Date';
}

// @public (undocumented)
export interface IDocInput {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    id?: never;
    // (undocumented)
    _id?: never;
    // (undocumented)
    slug?: string;
}

// @public (undocumented)
export interface IDocUpdateInput {
    // (undocumented)
    id: MongoIdExt;
    // Warning: (ae-forgotten-export) The symbol "UpdateParams" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    params?: UpdateParams;
    // Warning: (ae-forgotten-export) The symbol "UpdateQuery" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    query: UpdateQuery;
}

// @public (undocumented)
export interface IFilterPipelineInput {
    // (undocumented)
    [key: string]: (string | string[] | boolean | MatchFilter | undefined);
    // (undocumented)
    withDeleted?: boolean;
}

// @public (undocumented)
export interface IFiltersPipeline {
    // (undocumented)
    $and: ({
        [key: string]: unknown;
        deletedAt?: null;
    })[];
}

// @public (undocumented)
export interface IPageInfoInput {
    // (undocumented)
    current: number;
    // (undocumented)
    cursored: number;
    // (undocumented)
    total: number;
}

// @public (undocumented)
export interface IPaginator {
    // (undocumented)
    getPipeline: Function;
    // (undocumented)
    setPageInfo: Function;
}

// @public (undocumented)
export interface IPaginatorInput {
    // (undocumented)
    after?: string;
    // (undocumented)
    before?: string;
    // (undocumented)
    filters?: IFilterPipelineInput;
    // (undocumented)
    first?: number;
    // (undocumented)
    last?: number;
}

// @public (undocumented)
export type MatchFilter = {
    operator: ('STRICT_WORD' | 'CONTAINS_WORD' | 'CONTAINS_PART');
    value: (string | number);
};

// @public
export type MongoDBLink = string;

// @public
export type MongoDBName = string;

// @public
export type MongoDBOptions = {
    [key: string]: (string | number | boolean);
};

// @public
export type MongoDBParams = {
    [key: string]: (string | number | boolean);
};

// @public
export type MongoId = ObjectId;

// @public
export type MongoIdExt = ObjectId | string;

// @public
export type MongoIdStr = string;

// @public
export class Paginator implements IPaginator {
    constructor({ first, last, before, after, filters, }: IPaginatorInput);
    // (undocumented)
    protected currentPage: number;
    // (undocumented)
    protected field: string;
    // (undocumented)
    protected filters: IFilterPipelineInput;
    get(docs: Document_2[]): {
        edges: CursorEdge[];
        pageInfo: {
            hasNextPage: boolean;
            hasPreviousPage: boolean;
            totalPage: number;
            totalResults: number;
            currentPage: number;
            startCursor: any;
            endCursor: any;
        };
    };
    getDocCursor(doc: Document_2): any;
    getPipeline(customPipeline: Pipeline, reverse?: boolean): {
        [key: string]: any;
    }[];
    // (undocumented)
    protected hasNextPage: boolean;
    // (undocumented)
    protected hasPreviousPage: boolean;
    // (undocumented)
    protected limit: number;
    // @internal
    protected makeMatcher(reverse: boolean): any;
    // (undocumented)
    protected order: PaginatorOrder;
    // @internal
    static pipelineCleaner(pipeline: Pipeline): {
        [key: string]: any;
    }[];
    setCursor({ field, type }: ICursor): this;
    setPageInfo({ total, cursored, current }: IPageInfoInput): this;
    // (undocumented)
    protected totalPage: number;
    // (undocumented)
    protected totalResults: number;
    // (undocumented)
    protected type: ParseType | 'Date';
    // (undocumented)
    protected value: string | null;
}

// @public (undocumented)
export type PaginatorOrder = 'ASC' | 'DESC';

// @public (undocumented)
export type Pipeline = ({
    [key: string]: any;
})[];

// @public
export abstract class Repository extends MongoDataSource<Document_2> {
    canBeInserted(input: IDocInput): Promise<boolean>;
    canBeUpdated({ id, query }: IDocUpdateInput): Promise<boolean>;
    createDoc(input: IDocInput): Promise<DocumentResult>;
    createManyDocs(arr: IDocInput[]): Promise<DocumentResult[]>;
    protected cursor: ICursor;
    deleteById(id: MongoIdExt): Promise<any>;
    deleteManyById(ids: MongoIdExt[]): Promise<any>;
    findAll({ sort, order }: {
        sort?: string | undefined;
        order?: string | undefined;
    }): Promise<DocumentResult[]>;
    findByCursor(input: IPaginatorInput, pipeline?: Pipeline): Promise<{
        edges: CursorEdge[];
        pageInfo: {
            hasNextPage: boolean;
            hasPreviousPage: boolean;
            totalPage: number;
            totalResults: number;
            currentPage: number;
            startCursor: any;
            endCursor: any;
        };
    }>;
    findByFields(fields: Fields, options?: Options): Promise<(Document_2 | null | undefined)[]>;
    findManyByIds(ids: (string | ObjectId)[]): Promise<(Document_2 | null)[]>;
    findOneByFields(fields: Fields, options?: Options): Promise<DocumentResult>;
    findOneById(id: string | ObjectId): Promise<Document_2 | null>;
    findOneByIdOrThrow(id: MongoIdStr): Promise<Document_2>;
    findOneBySlug(slug: string, options?: Options): Promise<DocumentResult>;
    getDate(): Date;
    hardDeleteById(id: MongoIdExt): Promise<any>;
    hardDeleteManyById(ids: MongoIdExt[]): Promise<any>;
    prepareNewDoc(doc: IDocInput): Document_2;
    setGenericCursor(name: GenericCursors): this;
    updateDoc(input: IDocUpdateInput): Promise<DocumentResult>;
    // Warning: (ae-forgotten-export) The symbol "UpdateManyInput" needs to be exported by the entry point index.d.ts
    updateManyDoc({ filter, query }: UpdateManyInput): Promise<DocumentResult[]>;
}

```
